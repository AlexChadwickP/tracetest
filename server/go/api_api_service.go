/*
 * Project X
 *
 * OpenAPI definition for project X endpoint and resources
 *
 * API version: 0.0.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"fmt"
	"math/rand"
	"net/http"
	"time"

	"github.com/GIT_USER_ID/GIT_REPO_ID/go/tracedb"
	"github.com/google/uuid"
	"go.opentelemetry.io/otel/trace"
)

//go:generate mockgen -package=mocks -destination=mocks/testdb.go . TestDB
type TestDB interface {
	CreateTest(ctx context.Context, test *Test) (string, error)
	GetTests(ctx context.Context) ([]Test, error)
	GetTest(ctx context.Context, id string) (*Test, error)

	CreateResult(ctx context.Context, testID string, run *Result) error
	UpdateResult(ctx context.Context, run *Result) error
	GetResult(ctx context.Context, id string) (*Result, error)
	GetResultsByTestID(ctx context.Context, testid string) ([]Result, error)

	CreateAssertion(ctx context.Context, testid string, assertion *Assertion) (string, error)
	GetAssertion(ctx context.Context, id string) (*Assertion, error)
	GetAssertionsByTestID(ctx context.Context, testID string) ([]Assertion, error)
}

//go:generate mockgen -package=mocks -destination=mocks/executor.go . TestExecutor
type TestExecutor interface {
	Execute(test *Test, tid trace.TraceID, sid trace.SpanID) (*Result, error)
}

// ApiApiService is a service that implements the logic for the ApiApiServicer
// This service should implement the business logic for every endpoint for the ApiApi API.
// Include any external packages or services that will be required by this service.
type ApiApiService struct {
	traceDB  tracedb.TraceDB
	testDB   TestDB
	executor TestExecutor
	rand     *rand.Rand
}

// NewApiApiService creates a default api service
func NewApiApiService(traceDB tracedb.TraceDB, testDB TestDB, executor TestExecutor) ApiApiServicer {
	return &ApiApiService{
		traceDB:  traceDB,
		testDB:   testDB,
		executor: executor,
		rand:     rand.New(rand.NewSource(time.Now().UnixNano())),
	}
}

// CreateTest - Create new test
func (s *ApiApiService) CreateTest(ctx context.Context, test Test) (ImplResponse, error) {
	id, err := s.testDB.CreateTest(ctx, &test)
	if err != nil {
		return Response(http.StatusInternalServerError, err.Error()), err
	}

	test.Id = id
	return Response(200, test), nil
}

// GetTests - Gets all tests
func (s *ApiApiService) GetTests(ctx context.Context) (ImplResponse, error) {
	tests, err := s.testDB.GetTests(ctx)
	if err != nil {
		return Response(http.StatusInternalServerError, err.Error()), err
	}

	return Response(200, tests), nil
}

func (s *ApiApiService) TestsTestidRunPost(ctx context.Context, testid string) (ImplResponse, error) {
	t, err := s.testDB.GetTest(ctx, testid)
	//TODO switch on notFound
	if err != nil {
		return Response(http.StatusNotFound, err.Error()), err
	}

	id := uuid.New().String()
	tid := trace.TraceID{}
	s.rand.Read(tid[:])
	fmt.Printf("gen trace id: %v\n", tid)

	sid := trace.SpanID{}
	s.rand.Read(sid[:])
	fmt.Printf("gen span id: %v\n", sid)
	run := &Result{
		Id:        id,
		CreatedAt: time.Now(),
		Traceid:   tid.String(),
		Spanid:    sid.String(),
	}

	err = s.testDB.CreateResult(ctx, testid, run)
	if err != nil {
		return Response(http.StatusInternalServerError, err.Error()), err
	}

	go func(t *Test, tid trace.TraceID, sid trace.SpanID) {
		ctx := context.Background()
		fmt.Println("executing test")
		resp, err := s.executor.Execute(t, tid, sid)
		if err != nil {
			fmt.Printf("exec err: %s", err)
			return
		}
		fmt.Println(resp)

		run.CompletedAt = time.Now()
		err = s.testDB.UpdateResult(ctx, run)
		if err != nil {
			fmt.Printf("update result err: %s", err)
			return
		}
	}(t, tid, sid)

	return Response(200, TestRun{
		Id: id,
	}), nil
}

// TestsIdResultsGet -
func (s *ApiApiService) TestsIdResultsGet(ctx context.Context, id string) (ImplResponse, error) {
	res, err := s.testDB.GetResultsByTestID(ctx, id)
	if err != nil {
		return Response(http.StatusInternalServerError, err.Error()), err
	}

	return Response(http.StatusOK, res), nil

}

func (s *ApiApiService) TestsTestidResultsIdTraceGet(ctx context.Context, testID string, resultsID string) (ImplResponse, error) {
	res, err := s.testDB.GetResult(ctx, resultsID)
	if err != nil {
		return Response(http.StatusInternalServerError, err.Error()), err
	}

	tr, err := s.traceDB.GetTraceByID(ctx, res.Traceid)
	if err != nil {
		return Response(http.StatusInternalServerError, err.Error()), err
	}
	sid, err := trace.SpanIDFromHex(res.Spanid)
	if err != nil {
		return Response(http.StatusInternalServerError, err.Error()), err
	}

	tid, err := trace.TraceIDFromHex(res.Traceid)
	if err != nil {
		return Response(http.StatusInternalServerError, err.Error()), err
	}

	ttr := FixParent(tr, string(tid[:]), string(sid[:]))
	return Response(http.StatusOK, ttr), nil
}

// TestsTestidResultsIdGet -
func (s *ApiApiService) TestsTestidResultsIdGet(ctx context.Context, testid string, id string) (ImplResponse, error) {
	res, err := s.testDB.GetResult(ctx, id)
	if err != nil {
		return Response(http.StatusInternalServerError, err.Error()), err
	}

	return Response(http.StatusOK, []Result{*res}), nil
}

func (s *ApiApiService) CreateAssertion(ctx context.Context, testID string, assertion Assertion) (ImplResponse, error) {
	id, err := s.testDB.CreateAssertion(ctx, testID, &assertion)
	if err != nil {
		return Response(http.StatusInternalServerError, err.Error()), err
	}

	assertion.Id = id
	return Response(http.StatusOK, assertion), nil
}

func (s *ApiApiService) GetAssertions(ctx context.Context, testID string) (ImplResponse, error) {
	assertions, err := s.testDB.GetAssertionsByTestID(ctx, testID)
	if err != nil {
		return Response(http.StatusInternalServerError, err.Error()), err
	}

	return Response(http.StatusOK, assertions), nil
}
